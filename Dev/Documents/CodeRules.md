### Kotlin coding rule
아래 코딩 규칙이 의심스러운 경우, Java 코딩규칙
이름 지정 스타일이 의심스러운 경우 다음과 같은 Java 코딩 규칙이 기본값으로 사용됩니다.

	* 이름에 camelCase 사용 (변수명에 밑줄을 피하십시오)
	* Class명은 대문자로 시작
	* 메서드와 속성은 소문자로 시작합니다.
	* 4 칸의 들여 쓰기를 사용한다.
	* 공공 기능에는 Kotlin Doc에 나타나는 것과 같은 문서가 있어야합니다.

콜론콜론 앞에 공백이있어서 콜론이 유형과 수퍼 유형을 구분하며 콜론이 인스턴스와 유형을 구분하는 공백이 없습니다.
interface Foo<out T : Any> : Bar {
    fun foo(a: Int): T
}

- 람다람다 식에서는 매개 변수를 몸체와 구분하는 화살표 주위뿐만 아니라 중괄호 주위에 공백을 사용해야합니다. 가능할 때마다 람다는 괄호 밖으로 전달되어야합니다.
```
list.filter { it > 10 }.map { element -> element * 2 }
```

- 짧고 중첩 된 람다에서는 매개 변수를 명시 적으로 선언하는 대신 규칙을 사용하는 것이 좋습니다. 매개 변수가있는 중첩 된 람다에서 매개 변수는 항상 명시적으로 선언되어야합니다.
클래스 헤더 `서식인수`가 적은 클래스는 한 줄로 작성할 수 있습니다.
class Person(id: Int, name: String)

- 더 긴 헤더를 가진 클래스는 형식화되어야하며 각 기본 생성자 인수는 들여 쓰기가있는 별도의 행에 있어야합니다. 또한 닫는 괄호는 새 줄에 있어야합니다. 상속을 사용하는 경우, 슈퍼 클래스 생성자 호출 또는 구현 된 인터페이스 목록은 괄호와 같은 줄에 있어야합니다.
```
Class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name) {
    // ...
}
```

- 다중 인터페이스의 경우 수퍼 클래스 생성자 호출이 먼저 위치해야하며 각 인터페이스는 다른 행에 있어야합니다.
```
class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name),
    KotlinMaker {
    // ...
}
```

- 생성자 매개 변수는 일반 들여 쓰기 또는 연속 들여 쓰기 (일반 들여 쓰기의 두 배)를 사용할 수 있습니다.
- 단위함수가 Unit을 반환하면 반환 유형을 생략해야합니다.
```
fun foo() { // ": Unit" is omitted here

}
```

- 함수 vs 속성인수가 없는 함수는 읽기 전용 속성과 호환 될 수 있습니다. 의미가 비슷하지만 서로를 선호하는 경우에 대한 몇 가지 문체 규칙이 있습니다. 기본 알고리즘이 다음과 같은 경우 함수에 대한 특성을 선호하십시오.

	* return값이 없을 경우
	* O(1)복잡성을 가지는 경우
	* 간단한 계산인 경우 (첫 번째 실행에서 숨김).
	* 호출에 대해 동일한 결과를 반환하는 경우
